require "json"


data = File.read("./midis.jsonl")
song_count = data.lines.count

channels = 8
max_notes = 0 # TODO: dynamically (here) check which song is the longest and set this higher or lower as needed
end_note = -64
count = 0
File.open("./src/cone_light_songs.cpp", "w") do |f|
  f.puts "// DO NOT MANUALLY EDIT THIS FILE. ANY CHANGES WILL BE OVERWRITTEN WHEN REGENERATED BY THE 'jsonl_to_cone_light.rb' SCRIPT."
  f.puts "// File generated: #{Time.now.utc.strftime("%Y-%m-%d %H:%M:%S %Z")}"
  f.puts
  f.puts "#include \"cone_light_songs.h\""
  f.puts
  f.puts "const std::array<const String, #{song_count}> cone_light_song_titles = {"

  data.each_line do |line|
    hash = JSON.parse(line.strip, symbolize_names: true)

    f.puts  "        \"#{hash[:name]}\","

    hash[:notes].each do |array|
      # Add +1 so why have at least 1 END note
      max_notes = array.size + 1 if array.size > max_notes + 1
    end
  end

  f.puts "};"
  f.puts
  f.puts "const std::array<const std::array<int8_t, #{max_notes}>, #{song_count * channels}> cone_light_song_notes = {{"

  data.each_line do |line|
    hash = JSON.parse(line.strip, symbolize_names: true)

    note_rows = []
    hash[:notes].each do |note_array|
      notes = []
      max_notes.times do |i|
        if i >= note_array.size
          notes << end_note
        else
          notes << note_array[i]
        end
      end
      note_rows << "{#{notes.map { |n| n.positive? ? n + hash[:transpose] : n }.join(', ')}}"
    end
    f.puts "    /* SONG: #{hash[:name]} */"
    note_rows.join(",\n").lines.each_with_index do |line, i|
      f.print "    #{line}"
    end
    f.puts ","
  end

  f.puts "}};"
  f.puts
  f.puts "const std::array<const std::array<uint16_t, #{max_notes}>, #{song_count * channels}> cone_light_song_durations = {{"

  data.each_line do |line|
    hash = JSON.parse(line.strip, symbolize_names: true)

    note_rows = []
    hash[:durations].each do |note_array|
      # We rely on walking notes to know when the song is over, so we don't need to explicitly set duration to a MAGIC value to know when the song is complete
      note_rows << "{#{note_array.join(', ')}}"
    end
    f.puts "    /* SONG: #{hash[:name]} */"
    note_rows.join(",\n").lines.each_with_index do |line, i|
      f.print "    #{line}"
    end
    f.puts ","
  end

  f.puts "}};"
  f.puts
end

File.open("./include/cone_light_songs.h", "w") do |f|
  f.puts "#pragma once"
  f.puts
  f.puts "#include <array>"
  f.puts "#include <cstdint>"
  f.puts "#include <WString.h>"
  f.puts
  f.puts "extern const std::array<const String, #{song_count}> cone_light_song_titles;"
  f.puts "extern const std::array<const std::array<int8_t, #{max_notes}>, #{song_count * channels}> cone_light_song_notes;"
  f.puts "extern const std::array<const std::array<uint16_t, #{max_notes}>, #{song_count * channels}> cone_light_song_durations;"
  f.puts
end